(** Day 8: Resonant Collinearity *)

module Map = struct
  (** The type of antennas maps. *)
  type t = {
    n        : int;
    m        : int;
    antennas : (char, (int * int) list) Hashtbl.t;
  }

  (** [parse lines] parses a list of strings into an antennas map. *)
  let parse lines =
    let map =
      lines
      |> List.map (fun line -> Array.init (String.length line) (String.get line))
      |> Array.of_list
    in
    let n = Array.length map and m = Array.length map.(0)
    and antennas = Hashtbl.create 1024 in
    for i = 0 to n - 1 do
      for j = 0 to n - 1 do
        let freq = map.(i).(j) in
        if freq <> '.' then
          let coords = match Hashtbl.find_opt antennas freq with
            | Some coords -> coords
            | None        -> []
          in
          Hashtbl.replace antennas freq ((i, j) :: coords)
      done
    done;
    { n; m; antennas }

  (** [fold f t accu] folds the function [f] over the antennas in the map
      [t]. *)
  let fold f t =
    Hashtbl.fold f t.antennas
end

(** [inside_map n m (i, j)] checks whether the position [(i, j)] is within the
    bounds of the map. *)
let inside_map n m (i, j) =
  0 <= i && i < n && 0 <= j && j < m

(** [antinodes_for_antenna_pair1 n m a1 a2] computes the list of antinodes
    generated by the pair of antennas according to the rules of the part one of
    the problem. *)
let antinodes_for_antenna_pair1 n m (x1, y1) (x2, y2) =
  List.filter
    (inside_map n m)
    [(2 * x1 - x2, 2 * y1 - y2); (2 * x2 - x1, 2 * y2 - y1)]

(** [antinodes_for_antenna_pair1 n m a1 a2] computes the list of antinodes
    generated by the pair of antennas according to the rules of the part two of
    the problem. *)
let antinodes_for_antenna_pair2 n m (x1, y1) (x2, y2) =
  let rec gen accu (x1, y1) (x2, y2) i =
    let x' = (i + 1) * x1 - i * x2 and y' = (i + 1) * y1 - i * y2 in
    if inside_map n m (x', y') then
      gen ((x', y') :: accu) (x1, y1) (x2, y2) (i + 1)
    else
      accu
  in
  gen
    (gen [] (x2, y2) (x1, y1) 0)
    (x1, y1) (x2, y2) 0

(** A set of integer pairs. *)
module IntPairSet = Set.Make (struct type t = int * int let compare = compare end)

(** [antinodes_for_antenna_list gen_for_pair n m al] computes the set of all
    distinct antinodes generated by all unique pairs of antennas in the list
    [al]. *)
let antinodes_for_antenna_list gen_for_pair n m al =
  let rec iter1 antinodes = function
    | []      -> antinodes
    | a :: al -> iter1 (iter2 antinodes a al) al
  and iter2 antinodes a = function
    | []       -> antinodes
    | a' :: al ->
      iter2
        (List.fold_right IntPairSet.add (gen_for_pair n m a a') antinodes)
        a al
  in iter1 IntPairSet.empty al

(** [solve gen_for_pair t] computes the total number of distinct antinodes in
    the map [t]. *)
let solve gen_for_pair t =
  Map.(fold
         (fun _ ants accu ->
            IntPairSet.union accu (antinodes_for_antenna_list gen_for_pair t.n t.m ants))
         t IntPairSet.empty)
  |> IntPairSet.cardinal

let () =
  In_channel.with_open_text "input" @@ fun ic ->
  let map = In_channel.input_lines ic |> Map.parse in
  Printf.printf "Part One: %d\n" @@ solve antinodes_for_antenna_pair1 map;
  Printf.printf "Part One: %d\n" @@ solve antinodes_for_antenna_pair2 map
