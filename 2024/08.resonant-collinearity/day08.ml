(** Day 8: Resonant Collinearity *)

module Map = struct
  (** The type of antennas maps. *)
  type t = {
    n        : int;
    m        : int;
    antennas : (char, (int * int) list) Hashtbl.t;
  }

  (** [parse lines] parses an antennas map. *)
  let parse lines =
    let map =
      lines
      |> List.map (fun line -> Array.init (String.length line) (String.get line))
      |> Array.of_list
    in
    let n = Array.length map and m = Array.length map.(0)
    and antennas = Hashtbl.create 1024 in
    for i = 0 to n - 1 do
      for j = 0 to n - 1 do
        let freq = map.(i).(j) in
        if freq <> '.' then
          let coords = match Hashtbl.find_opt antennas freq with
            | Some coords -> coords
            | None        -> []
          in
          Hashtbl.replace antennas freq ((i, j) :: coords)
      done
    done;
    { n; m; antennas }

  (** [fold f t accu] folds the function [f] over the antennas in the map
      [t]. *)
  let fold f t =
    Hashtbl.fold f t.antennas
end

(** [antinodes_for_antenna_pair a1 a2] computes the list of antinodes generated
    by the pair of antennas. *)
let antinodes_for_antenna_pair (x1, y1) (x2, y2) =
  [(2 * x1 - x2, 2 * y1 - y2); (2 * x2 - x1, 2 * y2 - y1)]

(** A set of integer pairs. *)
module IntPairSet = Set.Make (struct type t = int * int let compare = compare end)

(** [antinodes_for_antenna_list n m al] computes the set of all distinct
    antinodes generated by all unique pairs of antennas in the list [al]. *)
let antinodes_for_antenna_list n m al =
  let rec iter1 antinodes = function
    | []      -> antinodes
    | a :: al -> iter1 (iter2 antinodes a al) al
  and iter2 antinodes a = function
    | []       -> antinodes
    | a' :: al ->
      iter2
        (List.fold_left
           (fun antinodes (i, j) ->
              if 0 <= i && i < n && 0 <= j && j < m then
                IntPairSet.add (i, j) antinodes
              else
                antinodes)
           antinodes
           (antinodes_for_antenna_pair a a'))
        a
        al
  in iter1 IntPairSet.empty al

(** [solve1 map] solves the part one of the problem. *)
let solve1 t =
  Map.(fold
         (fun _ ants accu ->
            IntPairSet.union accu (antinodes_for_antenna_list t.n t.m ants))
         t
         IntPairSet.empty)
  |> IntPairSet.cardinal

let () =
  In_channel.with_open_text "input" @@ fun ic ->
  let map = In_channel.input_lines ic |> Map.parse in
  Printf.printf "Part One: %d\n" @@ solve1 map
